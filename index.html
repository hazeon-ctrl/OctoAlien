<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brick Wall Defense â€” Mobile Friendly</title>
  <style>
    :root {
      --accent: #0ff;
      --bg1: #1a1a2e;
      --bg2: #16213e;
      --mono: 'Courier New', monospace;
    }

    html,body {
      height: 100%;
      margin: 0;
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color: #fff;
      font-family: var(--mono);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .wrap {
      max-width: 1000px;
      margin: 18px auto;
      padding: 0 18px 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
    }

    .hud {
      font-size: 18px;
      color: var(--accent);
      text-align: center;
    }

    .instructions {
      font-size: 13px;
      color: rgba(255,255,255,0.85);
      opacity: 0.9;
      text-align: center;
    }

    /* Canvas preserved at internal 800x600 for logic, but scaled responsively */
    #gameCanvas {
      border: 2px solid var(--accent);
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0,255,255,0.45);
      background: linear-gradient(180deg, #001122 0%, #003344 100%);
      display: block;
      width: min(100%, 880px);      /* visually responsive */
      height: auto;                 /* maintain aspect ratio */
      touch-action: none;           /* avoid gestures interfering */
      -webkit-user-select: none;
      user-select: none;
    }

    /* Game-over modal */
    .game-over {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%,-50%);
      background: rgba(0,0,0,0.9);
      padding: 26px;
      border-radius: 12px;
      border: 2px solid #ff0044;
      box-shadow: 0 0 30px rgba(255,0,68,0.7);
      display: none;
      z-index: 2000;
      text-align: center;
    }
    .restart-btn {
      background: var(--accent);
      color: #000;
      border: none;
      padding: 10px 18px;
      border-radius: 8px;
      cursor: pointer;
      font-family: inherit;
      font-size: 16px;
      margin-top: 12px;
    }

    /* MOBILE CONTROLS (visible on touch devices, hidden on desktop) */
    .mobile-controls {
      position: fixed;
      bottom: 18px;
      display: flex;
      gap: 12px;
      z-index: 1200;
      align-items: center;
      pointer-events: auto;
    }
    .mobile-controls.left { left: 12px; }
    .mobile-controls.right { right: 12px; }

    .ctl {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 2px solid rgba(0,255,255,0.18);
      background: rgba(0,255,255,0.10);
      color: var(--accent);
      font-size: 26px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      user-select: none;
      transition: transform 0.06s ease, background 0.12s;
      box-shadow: 0 6px 14px rgba(0,0,0,0.4);
    }
    .ctl.pressed {
      transform: translateY(2px) scale(0.96);
      background: rgba(0,255,255,0.28);
    }

    /* Hide controls on desktop with precise pointer */
    @media (hover: hover) and (pointer: fine) {
      .mobile-controls { display: none; }
    }

    /* Slightly smaller controls on tiny screens */
    @media (max-width: 360px) {
      .ctl { width: 56px; height: 56px; font-size: 22px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      Score: <span id="score">0</span> &nbsp; | &nbsp; Lives: <span id="lives">3</span> &nbsp; | &nbsp; Mothership: <span id="mothershipHealth">500</span>/500
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="instructions">
      A/D to move â€¢ SPACE to charge/detonate explosives â€¢ UP ARROW for auto-fire â€¢ BREAK THE WALL!<br>
      On touch: use the on-screen buttons (left/right/fire/bomb). Hold ðŸ”¥ to auto-fire; hold ðŸ’£ to charge and release to detonate.
    </div>
  </div>

  <!-- Mobile control buttons (left and right sides) -->
  <div class="mobile-controls left" aria-hidden="false">
    <button id="btnLeft" class="ctl" aria-label="Move left">âŸµ</button>
    <button id="btnRight" class="ctl" aria-label="Move right">âŸ¶</button>
  </div>

  <div class="mobile-controls right" aria-hidden="false">
    <button id="btnFire" class="ctl" aria-label="Auto fire">ðŸ”¥</button>
    <button id="btnBomb" class="ctl" aria-label="Bomb">ðŸ’£</button>
  </div>

  <div id="gameOver" class="game-over">
    <h2>Game Over!</h2>
    <p>Final Score: <span id="finalScore">0</span></p>
    <button class="restart-btn" onclick="restartGame()">Play Again</button>
  </div>

<script>
/* ------------------------------
   ORIGINAL GAME LOGIC (unchanged)
   ------------------------------ */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let audioCtx;
try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
} catch(e) {
    audioCtx = null;
}
function playSound(freq, duration, type = 'sine', volume = 0.1) {
    if (!audioCtx) return;
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    } catch(e) {}
}

let gameRunning = true;
let score = 0;
let lives = 3;
let mothershipHealth = 500;
let keys = {};
let spacePressed = false;
let chargeStartTime = 0;
let isCharging = false;
let lastBulletTime = 0;
let autoFireRate = 333;
let blastZones = [];

const player = {
    x: canvas.width / 2 - 25,
    y: canvas.height - 60,
    width: 50,
    height: 40,
    speed: 5
};

const mothership = {
    x: canvas.width / 2 - 120,
    y: 10,
    width: 240,
    height: 50,
    tentacleOffset: 0,
    baseX: canvas.width / 2 - 120,
    direction: 1,
    speed: 1.5,
    lastBombDrop: Date.now(),
    bombDropInterval: 2000,
    isEnraged: false
};

let bullets = [];
let explosives = [];
let particles = [];
let brickEnemies = [];
let bomberEnemies = [];
let bombs = [];

let brickSpawnTimer = 0;
let bomberSpawnTimer = 0;

/* keep existing keyboard listeners unchanged */
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (e.code === 'Space' && gameRunning) {
        e.preventDefault();
        if (!spacePressed) {
            spacePressed = true;
            if (explosives.length > 0) {
                detonateExplosive();
            } else {
                chargeStartTime = Date.now();
                isCharging = true;
                playSound(200, 0.8);
            }
        }
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    if (e.code === 'Space' && spacePressed) {
        spacePressed = false;
        if (isCharging) {
            isCharging = false;
            const chargeTime = Date.now() - chargeStartTime;
            if (chargeTime > 200) {
                fireExplosive(chargeTime);
            } else {
                shootBullet();
            }
        }
    }
});

/* --- shooting / explosives --- */
function shootBullet() {
    bullets.push({
        x: player.x + player.width / 2 - 2,
        y: player.y,
        width: 4,
        height: 10,
        speed: 8
    });
    playSound(800, 0.1);
}

function fireExplosive(chargeTime) {
    const maxChargeTime = 1200;
    const chargeRatio = Math.min(chargeTime / maxChargeTime, 1);
    const size = 8 + (chargeRatio * 16);

    explosives.push({
        x: player.x + player.width / 2 - size / 2,
        y: player.y,
        width: size,
        height: size,
        speed: 6,
        charge: chargeRatio,
        pulsate: 0
    });
    playSound(400, 0.3, 'triangle');
}

function detonateExplosive() {
    explosives.forEach((explosive) => {
        const radius = 60 + (explosive.charge * 80);
        const centerX = explosive.x + explosive.width/2;
        const centerY = explosive.y + explosive.height/2;

        createBigExplosion(centerX, centerY, radius);
        playSound(100, 0.8, 'sawtooth', 0.3);

        blastZones.push({
            x: centerX - radius,
            y: centerY - radius,
            width: radius * 2,
            height: radius * 2,
            duration: 5000,
            startTime: Date.now()
        });

        const points = Math.floor(10 + (explosive.charge * 20));

        brickEnemies = brickEnemies.filter(brick => {
            const distance = Math.sqrt(
                Math.pow(brick.x + brick.width/2 - centerX, 2) +
                Math.pow(brick.y + brick.height/2 - centerY, 2)
            );
            if (distance <= radius) {
                createExplosion(brick.x, brick.y, '#f44');
                score += points;
                return false;
            }
            return true;
        });

        bomberEnemies = bomberEnemies.filter(bomber => {
            const distance = Math.sqrt(
                Math.pow(bomber.x + bomber.width/2 - centerX, 2) +
                Math.pow(bomber.y + bomber.height/2 - centerY, 2)
            );
            if (distance <= radius) {
                createBigExplosion(bomber.x + bomber.width/2, bomber.y + bomber.height/2, 40);
                score += points * 3;
                return false;
            }
            return true;
        });

        if (checkCollision({
            x: centerX - radius/2,
            y: centerY - radius/2,
            width: radius,
            height: radius
        }, mothership)) {
            const damage = Math.floor(15 + (explosive.charge * 25));
            mothershipHealth -= damage;
            score += damage * 3;
            createBigExplosion(mothership.x + mothership.width/2, mothership.y + mothership.height/2, 30);

            if (mothershipHealth <= 0) {
                victory();
            }
        }

        updateUI();
    });
    explosives = [];
}

/* --- spawners / particles / helpers --- */
function spawnBrickEnemy() {
    const brickWidth = 25;
    const brickHeight = 15;
    const rows = 4;
    const cols = Math.floor(canvas.width / brickWidth);

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const x = col * brickWidth;
            const y = 80 + (row * brickHeight);

            const existingBrick = brickEnemies.find(brick =>
                Math.abs(brick.x - x) < brickWidth && Math.abs(brick.y - y) < brickHeight
            );

            const inBlastZone = blastZones.some(zone =>
                x + brickWidth > zone.x && x < zone.x + zone.width &&
                y + brickHeight > zone.y && y < zone.y + zone.height
            );

            if (!existingBrick && !inBlastZone && Math.random() > 0.7) {
                brickEnemies.push({
                    x: x,
                    y: y,
                    width: brickWidth,
                    height: brickHeight,
                    health: 1,
                    color: '#f44',
                    lastBombDrop: Date.now() + Math.random() * 3000
                });
            }
        }
    }
}

function spawnBomberEnemy() {
    const fromLeft = Math.random() > 0.5;
    const startX = fromLeft ? -60 : canvas.width + 10;
    const direction = fromLeft ? 1 : -1;

    bomberEnemies.push({
        x: startX,
        y: 250 + Math.random() * 100,
        baseY: 250 + Math.random() * 100,
        width: 60,
        height: 30,
        speed: 2 + Math.random(),
        direction: direction,
        waveOffset: Math.random() * Math.PI * 2,
        lastBombDrop: Date.now()
    });
}

function createExplosion(x, y, color = '#ff0') {
    for (let i = 0; i < 6; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 30,
            color: color
        });
    }
}

function createBigExplosion(x, y, radius) {
    const count = Math.floor(radius / 4);
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 10,
            vy: (Math.random() - 0.5) * 10,
            life: 50,
            color: ['#ff0', '#f80', '#f44'][i % 3]
        });
    }
}

function checkCollision(rect1, rect2) {
    return rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y;
}

/* --- update & render loops --- */
function update() {
    if (!gameRunning) return;

    if (keys['ArrowUp']) {
        const now = Date.now();
        if (now - lastBulletTime > autoFireRate) {
            shootBullet();
            lastBulletTime = now;
        }
    }

    const speed = isCharging ? player.speed * 0.5 : player.speed;
    if ((keys['KeyA'] || keys['ArrowLeft']) && player.x > 0) {
        player.x -= speed;
    }
    if ((keys['KeyD'] || keys['ArrowRight']) && player.x < canvas.width - player.width) {
        player.x += speed;
    }

    blastZones = blastZones.filter(zone => {
        return Date.now() - zone.startTime < zone.duration;
    });

    bullets = bullets.filter(bullet => {
        bullet.y -= bullet.speed;
        return bullet.y > -bullet.height;
    });

    explosives = explosives.filter(explosive => {
        explosive.y -= explosive.speed;
        explosive.pulsate += 0.3;
        return explosive.y > -explosive.height;
    });

    bombs = bombs.filter(bomb => {
        bomb.y += bomb.speed;
        if (bomb.explosive) {
            bomb.pulsate += 0.3;
        }

        if (checkCollision(bomb, player)) {
            if (bomb.explosive) {
                const explosionSize = bomb.isBossBomb ? 70 : 50;
                createBigExplosion(bomb.x, bomb.y, explosionSize);
                playSound(100, 0.8, 'sawtooth', 0.3);
                lives -= bomb.isBossBomb ? 3 : 2;
            } else {
                createExplosion(bomb.x, bomb.y, '#f44');
                lives--;
            }
            updateUI();
            if (lives <= 0) {
                gameOver();
            }
            return false;
        }

        if (bomb.explosive && bomb.y >= canvas.height - 20) {
            const explosionSize = bomb.isBossBomb ? 80 : 60;
            createBigExplosion(bomb.x, bomb.y, explosionSize);
            playSound(150, 0.3);
            return false;
        }

        return bomb.y < canvas.height;
    });

    brickEnemies.forEach(brick => {
        if (Date.now() - brick.lastBombDrop > 4000 + Math.random() * 6000) {
            bombs.push({
                x: brick.x + brick.width / 2 - 2,
                y: brick.y + brick.height,
                width: 4,
                height: 8,
                speed: 2,
                explosive: false
            });
            brick.lastBombDrop = Date.now();
        }
    });

    const healthPercentage = mothershipHealth / 500;
    if (healthPercentage <= 0.49 && !mothership.isEnraged) {
        mothership.isEnraged = true;
        playSound(150, 1, 'sawtooth', 0.4);
    }

    if (mothership.isEnraged) {
        mothership.x += mothership.speed * mothership.direction;

        if (mothership.x <= -40 || mothership.x >= canvas.width - mothership.width + 40) {
            mothership.direction *= -1;
        }

        if (Date.now() - mothership.lastBombDrop > mothership.bombDropInterval) {
            bombs.push({
                x: mothership.x + mothership.width / 2 - 4,
                y: mothership.y + mothership.height,
                width: 8,
                height: 12,
                speed: 2.5,
                color: '#f0f',
                explosive: true,
                pulsate: 0,
                isBossBomb: true
            });
            mothership.lastBombDrop = Date.now();
            playSound(300, 0.3, 'triangle', 0.2);
        }
    }

    bomberEnemies = bomberEnemies.filter(bomber => {
        bomber.x += bomber.speed * bomber.direction;
        bomber.waveOffset += 0.05;
        bomber.y = bomber.baseY + Math.sin(bomber.waveOffset) * 20;

        if (Date.now() - bomber.lastBombDrop > 1000) {
            bombs.push({
                x: bomber.x + bomber.width / 2 - 5,
                y: bomber.y + bomber.height,
                width: 10,
                height: 15,
                speed: 2.5,
                color: '#f40',
                explosive: true,
                pulsate: 0,
                isBossBomb: false
            });
            bomber.lastBombDrop = Date.now();
        }

        return bomber.direction > 0 ? bomber.x < canvas.width + 80 : bomber.x > -80;
    });

    bullets.forEach((bullet, bulletIndex) => {
        if (checkCollision(bullet, mothership)) {
            createExplosion(bullet.x, bullet.y, '#0f0');
            playSound(300, 0.2);
            bullets.splice(bulletIndex, 1);
            mothershipHealth -= 3;
            score += 25;
            updateUI();

            if (mothershipHealth <= 0) {
                victory();
            }
            return;
        }

        brickEnemies.forEach((brick, brickIndex) => {
            if (checkCollision(bullet, brick)) {
                createExplosion(brick.x, brick.y, '#f44');
                playSound(150, 0.2);
                bullets.splice(bulletIndex, 1);
                brickEnemies.splice(brickIndex, 1);
                score += 10;
                updateUI();
                return;
            }
        });

        bomberEnemies.forEach((bomber, bomberIndex) => {
            if (checkCollision(bullet, bomber)) {
                createBigExplosion(bomber.x + bomber.width/2, bomber.y + bomber.height/2, 30);
                playSound(250, 0.4);
                bullets.splice(bulletIndex, 1);
                bomberEnemies.splice(bomberIndex, 1);
                score += 50;
                updateUI();
                return;
            }
        });

        bombs.forEach((bomb, bombIndex) => {
            if (checkCollision(bullet, bomb)) {
                createExplosion(bomb.x, bomb.y, '#ff0');
                playSound(400, 0.15);
                bullets.splice(bulletIndex, 1);
                bombs.splice(bombIndex, 1);
                score += 5;
                updateUI();
                return;
            }
        });
    });

    particles = particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.life--;
        return particle.life > 0;
    });

    brickSpawnTimer++;
    if (brickSpawnTimer > 120) {
        spawnBrickEnemy();
        brickSpawnTimer = 0;
    }

    bomberSpawnTimer++;
    if (bomberSpawnTimer > 480) {
        spawnBomberEnemy();
        bomberSpawnTimer = 0;
    }
}

function render() {
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#001122');
    gradient.addColorStop(1, '#003344');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    for (let i = 0; i < 40; i++) {
        const x = (i * 137.5) % canvas.width;
        const y = (i * 67.3) % canvas.height;
        ctx.fillRect(x, y, 1, 1);
    }

    mothership.tentacleOffset += 0.08;

    ctx.fillStyle = mothershipHealth > 200 ? '#a0a' : mothershipHealth > 100 ? '#c06' : '#f04';
    ctx.fillRect(mothership.x + 80, mothership.y, 80, 50);

    ctx.fillStyle = mothershipHealth > 100 ? '#f00' : '#fff';
    ctx.fillRect(mothership.x + 90, mothership.y + 15, 8, 8);
    ctx.fillRect(mothership.x + 142, mothership.y + 15, 8, 8);

    const tentacleSpeed = mothership.isEnraged ? 0.4 : (mothershipHealth < 200 ? 0.3 : 0.15);
    const tentacleColor = mothership.isEnraged ? '#c08' : (mothershipHealth > 200 ? '#808' : '#a06');
    ctx.strokeStyle = tentacleColor;
    ctx.lineWidth = mothership.isEnraged ? 6 : 5;
    for (let i = 0; i < 10; i++) {
        const tentacleX = mothership.x + 10 + (i * 22);
        const waveIntensity = mothership.isEnraged ? 20 : 12;
        const waveY = Math.sin(mothership.tentacleOffset * tentacleSpeed + i * 0.6) * waveIntensity;

        ctx.beginPath();
        ctx.moveTo(tentacleX, mothership.y + 50);
        ctx.quadraticCurveTo(
            tentacleX + 8, mothership.y + 70 + waveY,
            tentacleX + 15, mothership.y + 90 + waveY * 1.5
        );
        ctx.stroke();
    }

    const barWidth = 200;
    const barX = canvas.width / 2 - barWidth / 2;
    const barY = 70;

    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.fillRect(barX, barY, barWidth, 6);

    const healthRatio = Math.max(0, mothershipHealth / 500);
    ctx.fillStyle = healthRatio > 0.6 ? '#0f0' : healthRatio > 0.3 ? '#ff0' : '#f00';
    ctx.fillRect(barX, barY, barWidth * healthRatio, 6);

    ctx.fillStyle = '#fff';
    ctx.font = '12px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`MOTHERSHIP: ${Math.max(0, mothershipHealth)}/500`, canvas.width / 2, barY - 5);
    ctx.textAlign = 'left';

    blastZones.forEach(zone => {
        const age = Date.now() - zone.startTime;
        const lifeRatio = 1 - (age / zone.duration);

        ctx.fillStyle = `rgba(255, 100, 100, ${0.1 * lifeRatio})`;
        ctx.fillRect(zone.x, zone.y, zone.width, zone.height);

        ctx.strokeStyle = `rgba(255, 150, 150, ${0.3 * lifeRatio})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(zone.x, zone.y, zone.width, zone.height);
    });

    brickEnemies.forEach(brick => {
        ctx.fillStyle = brick.color;
        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);

        ctx.strokeStyle = '#800';
        ctx.lineWidth = 1;
        ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
    });

    ctx.fillStyle = '#0ff';
    ctx.fillRect(player.x, player.y, player.width, player.height);
    ctx.fillStyle = '#fff';
    ctx.fillRect(player.x + 20, player.y + 15, 10, 4);

    bullets.forEach(bullet => {
        ctx.fillStyle = '#ff0';
        ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
    });

    explosives.forEach(explosive => {
        const pulse = 0.7 + 0.3 * Math.sin(explosive.pulsate * 10);
        ctx.fillStyle = `rgba(255, 0, 255, ${pulse})`;
        ctx.fillRect(explosive.x, explosive.y, explosive.width, explosive.height);

        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(explosive.x - 2, explosive.y - 2, explosive.width + 4, explosive.height + 4);
    });

    bombs.forEach(bomb => {
        if (bomb.explosive) {
            const pulseBrightness = 0.6 + 0.4 * Math.sin(bomb.pulsate * 6);

            if (bomb.isBossBomb) {
                ctx.fillStyle = `rgba(255, 0, 255, ${pulseBrightness})`;
                ctx.shadowColor = '#f0f';
                ctx.shadowBlur = 12;
            } else {
                ctx.fillStyle = `rgba(255, 68, 0, ${pulseBrightness})`;
                ctx.shadowColor = bomb.color;
                ctx.shadowBlur = 8;
            }

            ctx.fillRect(bomb.x, bomb.y, bomb.width, bomb.height);
            ctx.shadowBlur = 0;

            ctx.strokeStyle = bomb.isBossBomb ? '#fff' : '#ff0';
            ctx.lineWidth = bomb.isBossBomb ? 2 : 1;
            ctx.strokeRect(bomb.x - 1, bomb.y - 1, bomb.width + 2, bomb.height + 2);
        } else {
            ctx.fillStyle = bomb.color || '#f80';
            ctx.fillRect(bomb.x, bomb.y, bomb.width, bomb.height);
        }
    });

    bomberEnemies.forEach(bomber => {
        ctx.fillStyle = '#f84';
        ctx.fillRect(bomber.x, bomber.y, bomber.width, bomber.height);

        ctx.fillStyle = '#666';
        ctx.fillRect(bomber.x - 5, bomber.y + 10, 10, 6);
        ctx.fillRect(bomber.x + bomber.width - 5, bomber.y + 10, 10, 6);
    });

    particles.forEach(particle => {
        ctx.fillStyle = particle.color;
        ctx.globalAlpha = particle.life / 50;
        ctx.fillRect(particle.x, particle.y, 2, 2);
        ctx.globalAlpha = 1;
    });

    if (isCharging) {
        const chargeTime = Date.now() - chargeStartTime;
        const chargeRatio = Math.min(chargeTime / 1200, 1);

        const barWidth = 60;
        const barX = player.x + player.width / 2 - barWidth / 2;
        const barY = player.y - 20;

        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(barX, barY, barWidth, 4);

        ctx.fillStyle = chargeRatio < 1 ? '#ff0' : '#f0f';
        ctx.fillRect(barX, barY, barWidth * chargeRatio, 4);
    }
}

function gameLoop() {
    update();
    render();
    requestAnimationFrame(gameLoop);
}

/* --- UI / endgame --- */
function updateUI() {
    document.getElementById('score').textContent = score;
    document.getElementById('lives').textContent = lives;
    document.getElementById('mothershipHealth').textContent = Math.max(0, mothershipHealth);
}

function gameOver() {
    gameRunning = false;
    playSound(220, 1, 'triangle');
    document.getElementById('finalScore').textContent = score;
    document.getElementById('gameOver').style.display = 'block';
}

function victory() {
    gameRunning = false;
    playSound(523, 0.8, 'triangle');
    document.getElementById('gameOver').innerHTML = `
            <h2 style="color: #0f0;">VICTORY!</h2>
            <p>The mothership is destroyed!</p>
            <p>Final Score: ${score}</p>
            <button class="restart-btn" onclick="restartGame()">Play Again</button>
        `;
    document.getElementById('gameOver').style.display = 'block';
}

function restartGame() {
    gameRunning = true;
    score = 0;
    lives = 3;
    mothershipHealth = 500;
    mothership.x = mothership.baseX;
    mothership.direction = 1;
    mothership.isEnraged = false;
    mothership.lastBombDrop = Date.now();
    bullets = [];
    explosives = [];
    particles = [];
    brickEnemies = [];
    bomberEnemies = [];
    bombs = [];
    blastZones = [];
    brickSpawnTimer = 0;
    bomberSpawnTimer = 0;
    spacePressed = false;
    isCharging = false;
    player.x = canvas.width / 2 - 25;
    document.getElementById('gameOver').style.display = 'none';
    updateUI();
}

/* ------------------------------
   MOBILE / TOUCH BINDINGS (new)
   ------------------------------ */

/* Simulate keyboard behavior for the on-screen buttons.
   It duplicates the Space handling so button holds/releases
   behave exactly like physical key presses.
*/
function simulateKey(code, isDown) {
    keys[code] = isDown;
    if (code === 'Space') {
        if (isDown && gameRunning) {
            if (!spacePressed) {
                spacePressed = true;
                if (explosives.length > 0) {
                    detonateExplosive();
                    // small haptic (optional)
                    if (navigator.vibrate) navigator.vibrate(40);
                } else {
                    chargeStartTime = Date.now();
                    isCharging = true;
                    playSound(200, 0.8);
                }
            }
        } else if (!isDown && spacePressed) {
            spacePressed = false;
            if (isCharging) {
                isCharging = false;
                const chargeTime = Date.now() - chargeStartTime;
                if (chargeTime > 200) {
                    fireExplosive(chargeTime);
                    if (navigator.vibrate) navigator.vibrate([20,40]);
                } else {
                    shootBullet();
                }
            }
        }
    }
}

/* Attach pointer-friendly handlers to a button element */
function bindControlButton(btnId, keyCode) {
    const btn = document.getElementById(btnId);
    // visual feedback & prevent gestures
    btn.style.touchAction = 'none';
    btn.addEventListener('pointerdown', (ev) => {
        ev.preventDefault();
        btn.classList.add('pressed');
        btn._pointerId = ev.pointerId;
        simulateKey(keyCode, true);
    }, {passive:false});
    btn.addEventListener('pointerup', (ev) => {
        // only release if same pointer
        if (btn._pointerId !== undefined && ev.pointerId !== btn._pointerId) return;
        ev.preventDefault();
        btn.classList.remove('pressed');
        btn._pointerId = undefined;
        simulateKey(keyCode, false);
    }, {passive:false});
    btn.addEventListener('pointercancel', (ev) => {
        if (btn._pointerId !== undefined && ev.pointerId !== btn._pointerId) return;
        ev.preventDefault();
        btn.classList.remove('pressed');
        btn._pointerId = undefined;
        simulateKey(keyCode, false);
    }, {passive:false});

    // fallback for very old browsers (touch)
    if (!window.PointerEvent) {
        btn.addEventListener('touchstart', (ev) => { ev.preventDefault(); btn.classList.add('pressed'); simulateKey(keyCode, true); }, {passive:false});
        btn.addEventListener('touchend', (ev) => { ev.preventDefault(); btn.classList.remove('pressed'); simulateKey(keyCode, false); }, {passive:false});
    }
}

/* Bindings: left, right, auto-fire, bomb */
bindControlButton('btnLeft', 'KeyA');
bindControlButton('btnRight', 'KeyD');
bindControlButton('btnFire', 'ArrowUp');  // hold to auto-fire
bindControlButton('btnBomb', 'Space');    // hold to charge + release to detonate

/* Prevent default contextmenu on long press inside canvas */
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

/* Start the game */
updateUI();
gameLoop();

</script>
</body>
</html>
